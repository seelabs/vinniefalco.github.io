<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>http::stream::async_write (2 of 2 overloads)</title>
<link rel="stylesheet" href="../../../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../../../index.html" title="Beast">
<link rel="up" href="../async_write.html" title="http::stream::async_write">
<link rel="prev" href="overload1.html" title="http::stream::async_write (1 of 2 overloads)">
<link rel="next" href="../cancel.html" title="http::stream::cancel">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Beast Logo" width="1007" height="107" src="../../../../images/beast.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="overload1.html"><img src="../../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_write.html"><img src="../../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../images/home.png" alt="Home"></a><a accesskey="n" href="../cancel.html"><img src="../../../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="beast.ref.http__stream.async_write.overload2"></a><a class="link" href="overload2.html" title="http::stream::async_write (2 of 2 overloads)">http::stream::async_write
          (2 of 2 overloads)</a>
</h5></div></div></div>
<p>
            Start pipelining a HTTP message to the stream asynchronously.
          </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">bool</span> <a class="link" href="../../../../">isRequest</a><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">Body</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">Headers</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">WriteHandler</span><span class="special">&gt;</span>
<a class="link" href="../../../../"><span class="emphasis"><em>void-or-deduced</em></span></a>
<span class="identifier">async_write</span><span class="special">(</span>
    <span class="identifier">message</span><span class="special">&lt;</span> <span class="identifier">isRequest</span><span class="special">,</span> <span class="identifier">Body</span><span class="special">,</span> <span class="identifier">Headers</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">msg</span><span class="special">,</span>
    <span class="identifier">WriteHandler</span> <span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">);</span>
</pre>
<p>
            This function is used to queue a message to be sent on the stream. Unlike
            the free function, this version will place the message on an outgoing
            message queue if there is already a write pending.If the semantics of
            the message require that the connection is closed to indicate the end
            of the content body, the handler is called with the error boost::asio::error::eof.
            The caller is responsible for actually closing the connection. For regular
            TCP/IP streams this means shutting down the send side, while SSL streams
            may call the SSL async_shutdown function.msgThe message to send. Ownership
            of the message, which must be movable, is transferred to the implementation.
            The message will not be destroyed until the asynchronous operation completes.handlerThe
            handler to be called when the request completes. Copies will be made
            of the handler as required. The equivalent function signature of the
            handler must be: voidhandler(error_codeconst&amp;error//resultofoperation);
            Regardless of whether the asynchronous operation completes immediately
            or not, the handler will not be invoked from within this function. Invocation
            of the handler will be performed in a manner equivalent to using boost::asio::io_service::post().
          </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2016 Vinnie
      Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="overload1.html"><img src="../../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_write.html"><img src="../../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../images/home.png" alt="Home"></a><a accesskey="n" href="../cancel.html"><img src="../../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
